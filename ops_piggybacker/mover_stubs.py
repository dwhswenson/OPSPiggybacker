import openpathsampling as paths

class NoEngine(paths.engines.DynamicsEngine):
    pass

class ShootingStub(paths.pathmover.PathMover):
    def __init__(self, ensemble, selector=None, engine=None):
        super(ShootingStub, self).__init__()
        if engine is None:
            engine = NoEngine()
        if selector is None:
            selector = paths.UniformSelector()  # default
        self.engine = engine
        self.selector = selector
        self.ensemble = ensemble
        self.mimic = paths.OneWayShootingMover(ensemble, selector, engine)


    def move(self, input_sample, trial_trajectory, shooting_point, accepted):
        """Fake a move.

        Parameters
        ----------
        input_sample: :class:`paths.Sample`
            the input sample for this shooting move
        trial_trajectory: :class:`paths.Trajectory`
            the trial trajectory generated by this move
        shooting_point: :class:`paths.Snapshot`
            the shooting point snapshot for this trial
        accepted: bool
            whether the trial was accepted
        """
        initial_trajectory = input_sample.trajectory
        replica = input_sample.replica
        ensemble = input_sample.ensemble

        # determine the direction
        shared = trial_trajectory.shared_subtrajectory(initial_trajectory)
        if shared[0] == trial_trajectory[0]:
            choice = 0  # forward submover
        elif shared[-1] == trial_trajectory[-1]:
            choice = 1  # backward submover
        else:
            raise RuntimeError("Are you sure this is 1-way shooting?")


        trial_details = paths.SampleDetails(
            initial_trajectory=initial_trajectory,
            shooting_snapshot=shooting_point
        )

        trial = paths.Sample(
            replica=replica,
            trajectory=trial_trajectory,
            ensemble=ensemble,
            parent=input_sample,
            details=trial_details,
            mover=self.mimic.movers[choice]
        )

        trials = [trial]
        move_details = paths.MoveDetails()

        if accepted:
            inner = paths.AcceptedSamplePathMoveChange(
                samples=trials,
                mover=self.mimic.movers[choice],
                details=move_details
            )
        else:
            inner = paths.RejectedSamplePathMoveChange(
                samples=trial,
                mover=self.mimic.movers[choice],
                details=move_details
            )

        rc_details = paths.MoveDetails()
        rc_details.inputs = []
        rc_details.choice = choice
        rc_details.chosen_mover = self.mimic.movers[choice]
        rc_details.probability = 0.5
        rc_details.weights = [1, 1]

        return paths.RandomChoicePathMoveChange(
            subchange=inner,
            mover=self.mimic,
            details=rc_details
        )
